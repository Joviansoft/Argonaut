{"name":"Argonaut","tagline":"AS3/JSON serializer/deserializer","body":"Argonaut provides a simple way for Actionscript clients to share classes with servers through JSON.\r\n\r\nServers can (and routinely do) return data formatted as JSON, a data format more concise than XML and more human-readable than AMF. You may have loaded some JSON in the past and hand-tooled an interpreter to convert the JSON into something useful in AS3. Something like this:\r\n\r\n    var jsonString:String = someDataILoaded;\r\n    var json:Object = JSON.parse(jsonString);\r\n    var instance:MyClass = new MyClass();\r\n    instance.someValue = json.someValue;\r\n    instance.someOtherValue = json.someOtherValue;\r\n\r\nThis is pretty tedious and error-prone, and can be difficult if your JSON has deeply nested elements. Argonaut bypasses all this hand-tooling by automating the process. What’s more (and better) is that Argonaut provides a method to automatically identify which class(es) the JSON maps to.\r\n\r\n### How we use JSON\r\n\r\nSo we call a server and get some JSON back. Often this JSON is structured around the data’s logical use. For example, a server call might return some JSON like this:\r\n\r\n    {\r\n        “name”:”Argo”,\r\n        “launchDate”:10403500012,\r\n        “captain”:”Jason”,\r\n        “complement”: [\r\n            {\r\n\t\t“name”:“Bellerophon”,\r\n\t\t“age”:21\r\n\t    },\r\n\t    {\r\n    \t\t“name”:“Castor”,\r\n    \t\t“age”:22\r\n\t    },\r\n\t    {\r\n    \t\t“name”:“Heracles”,\r\n    \t\t“age”:30\r\n\t    }\r\n        ]\r\n    }\r\n\r\nThe data here might be reflected in an EpicGalley class. Possibly the server has an EpicGalley.java or EpicGalley.php class and the client has an EpicGalley.as class. Not an unusual setup when sharing data back and forth. But note how this bit of JSON also includes an array of other objects, perhaps instances of a Hero.as class. You can easily see how this would look in AS3 with a bit of hand tooling:\r\n\r\n    var galley:EpicGalley = new EpicGalley();\r\n    galley.name = json.name;    //assumes we have some JSON to work with\r\n    galley.captain = json.captain;\r\n    galley.launchDate = json.launchDate;\r\n    galley.complement = [];\r\n    var aa:uint = json.complement.length;\r\n    for (var a:uint = 0; a < aa; a++)\r\n    {\r\n        var hero:Hero = new Hero();\r\n        hero.name = json.complement[a].name;\r\n        hero.age = json.complement[a].age;   \r\n\tgalley.complement.push(hero);\r\n    }\r\n\r\nThat gets to be a lot of code, even in this simple example; again, it’s tedious and error-prone, and doesn’t scale well if the JSON turns out to be complex and full of deeply nested elements. Now let’s look at how Argonaut handles the same problem:\r\n\r\n    var argonaut:Argonaut = new Argonaut();\r\n    argonaut.registerClassAlias(“com.example.EpicGalley”, EpicGalley);\r\n    argonaut.registerClassAlias(\"com.example.Hero\", Hero);\r\n    var galley:EpicGalley = argonaut.generate(json);\r\n\r\nArgonaut uses reflection to analyze mapped classes and can use these mappings to infer a lot of information about the JSON it's processing. For example, if the mapped AS class uses a typed Vector to store the JSON array of Heroes, Argonaut knows to manufacture Hero classes from the JSON array. Argonaut understands all common JSON data types (Number, String, Boolean, Object, Array and Null) and can also interpret JSON as custom classes or even core Actionscript classes (e.g., Sprite or BitmapData). Additionally, Argonaut allows the JSON to provide deterministic mappings to remove any guessing.\r\n\r\nSo let’s look at Argonaut’s two basic deserialization use cases. We call these “participating” and “non-participating” JSON.\r\n\r\n\r\n-- PARTICIPATING JSON\r\n\r\nIf you have a server-side developer who loves you (or at least tolerates your presence), you can ask him to identify the class right in the JSON using an alias tag. By default, this tag is ‘__jsonclass__’ (consistent with json-rpc), but you can reset it to anything you agree on.\r\n\r\nThe participating JSON would look like this:\r\n\r\n    {\r\n        “__jsonclass__”:”com.example.EpicGalley”\r\n        “name”:”Argo”,\r\n        “launchDate”:10403500012,\r\n        “captain”:”Jason”,\r\n        “complement”: [\r\n    \t\t{\r\n                    “__jsonclass__”:”com.example.Hero”\r\n\t\t\t“name”:“Bellerophon”,\r\n\t\t\t“age”:21\r\n\t\t},\r\n        //The rest of the crew manifest\r\n\t]\r\n    }\r\n\r\nYou then apply the code I noted above and poof! out pops an AS3 instance.\r\n\r\n    var argonaut:Argonaut = new Argonaut();\r\n    //NB: these next two lines are required just once per runtime\r\n    argonaut.registerClassAlias(“com.example.EpicGalley”, EpicGalley);\r\n    argonaut.registerClassAlias(\"com.example.Hero\", Hero);\r\n    //This single line is all that’s really required for serialization\r\n    var galley:EpicGalley = argonaut.generate(json);\r\n\r\n## NON-PARTICIPATING JSON\r\n\r\nOf course the service you call may be outside your control, and the service developer too busy going to parties to add an alias. Never fear! That dev may never love you the way that I do, but that doesn’t mean you can’t parse his JSON. When dealing with non-participating JSON, simply provide Argonaut with the class manually:\r\n\r\n    var galley:EpicGalley = argonaut.generateAs(json, EpicGalley);\r\n\r\nThe obvious limitation with this approach is that you need to know what kind of class you’re expecting to receive, and provide it to Argonaut every time.\r\n\r\nAlso, note that — because Argonaut uses the mapped class’s property/data type mappings — we only need to provide the class of the enclosing instance. Everything inside that instance will be coerced as those mappings dictate.\r\n\r\n## SERIALIZATION\r\n\r\nArgonaut is really about inbound data (i.e., receiving and de-serializing JSON), but an outbound pipeline is also useful if you want to dispatch classes as JSON. The JSON class in AS3 does this (partially) by providing the JSON.stringify() method, but it has a rather serious limitation: there’s no way to suppress properties that aren’t needed for serialization.\r\n\r\nFor example, you might have this Class:\r\n\r\n    public class Example\r\n    {\r\n        public var name:String;\r\n\tpublic var id:uint;\r\n        public const gravity:Number = 9.8;\r\n\tpublic var textField:TextField;\r\n    }\r\n\r\nWhen sending the JSON, you probably want to send name and id, but the constant gravity and the (very complex!) textField property probably shouldn’t go over the wire. To fix this, Argonaut provides a `[DontSerialize]` metatag. Edit the class to:\r\n\r\n    public class Example\r\n    {\r\n        public var name:String;\r\n    \tpublic var id:uint;\r\n\t[DontSerialize]\r\n        public const gravity:Number = 9.8;\r\n        [DontSerialize]\r\n\tpublic var textField:TextField;\r\n    }\r\n\r\nIf you run the instance through argonaut.stringify(), the resulting JSON will only include only that name and id fields. Note that use of the [DontSerialize] metatag requires -keep-as3-metadata+=“DontSerialize” to be marked in the compiler.\r\n\r\n    -static-link-runtime-shared-libraries=true\r\n    -target-player={playerVersion}\r\n    -library-path+=\"{flexSDK}/frameworks/locale/en_US\"\r\n    -default-size=550,400\r\n    -use-network=false\r\n    -keep-as3-metadata+=“DontSerialize”\r\n\r\nFinally, the Argonaut serializer automatically tags JSON objects with a “__jsonclass__” tag so that a recipient may also know the datatype of any complex objects.\r\n\r\n## ACKNOWLEDGEMENTS\r\nI am indebted to Rocket Ninja, Inc. for their assistance in the development of this utility.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}